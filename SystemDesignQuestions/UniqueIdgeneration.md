# Unique Id generation in distributed systems

## Existing Solutions
### UUID
UUIDs are 128-bit hexadecimal numbers that are globally unique. The chances of the same UUID getting generated twice is negligible.

The major disadvantage of UUIDs is the length of the ID. Each ID is a 128-bit (32 char) long number. The large size of the ID means it will take more storage space, and will increase the response time of the machine in retrieving or using the IDs. Additionally, by default, GUIDs are not sequential. As discussed above, though newsequentialid() can make the IDs sequential for a single machine, itâ€™s not possible to guarantee the same for multiple machines. However, time-stamped GUIDs can solve this problem.

### MongoDBâ€™s ObjectId

MongoDBâ€™s ObjectIDs are 12-byte (96-bit) hexadecimal numbers that are made up of -

a 4-byte epoch timestamp in seconds,
a 3-byte machine identifier,
a 2-byte process id, and
a 3-byte counter, starting with a random value.

This is smaller than the earlier 128-bit UUID. But again the size is relatively longer than what we normally have in a single MySQL auto-increment field (a 64-bit bigint value).

### Database Ticket Servers

This approach uses a centralized database server to generate unique incrementing IDs. Itâ€™s like a centralized auto-increment. This approach is used by Flickr.

### Twitter snowflake

Twitter Snowflake optimizes the original concept of UUIDs to work on a large scale, while keeping the IDs sortable and the ID size manageable. Itâ€™s an ideal example to base our design on.

![image](https://user-images.githubusercontent.com/33947539/150521064-129a41af-b3b4-46ac-9d59-6b58852048d2.png)

Twitter Snowflake creates a 64-bit random, unique ID (as compared to 128-bit UUID). The ID is composed of:

- 41-bit Epoch timestamp (with millisecond precision)
- 10-bit machine ID (accommodates 1024 machines)
- 12-bit counter bits (generated by a local counter for every machine that rolls over when the number turns 4096)
- 1 extra bit for future use. By default, this bit is set to 0.

Epoch timestamp in millisecond â€” 41 bits (gives us 69 years with respect to any custom epoch)
Configured machine/node/shard Id â€” 10 bits (gives us up to a total of 2^10 i.e 1024 Ids)
Sequence number â€” 12 bits (A local counter per machine that sets to zero after every 4096 values)
The extra 1 reserved bit at the beginning is set as 0 to make the overall number as positive.

![image](https://user-images.githubusercontent.com/33947539/150532846-5d378372-48d1-4f44-8a3b-73f5babd8363.png)



#### Advantages And Disadvantages of Twitter Snowflake

Unlike UUIDs, Twitter Snowflake IDs are sortable by time since they have a timestamp at the beginning. 
ðŸ‘‰ This makes them ideal for indexing. 

Additionally, since theyâ€™re 64-bit long, theyâ€™re half the size of UUIDs, practically cutting down the storage size and processing times by half. 

ðŸ‘‰ Also, the approach is scalable, considering the fact that it can accommodate 1024 machines. It is highly available, since there can be 1024 machines, where each machine can generate 4096 unique IDs each millisecond (the system also prevents rollover in the same millisecond).

On the downside, the design requires Zookeeper to maintain Machine IDs. Also, the generated IDs are not random, unlike UUIDs. Since the future IDs are predictable, the design may not be applicable to applications where security is a requirement.

## Designing A Customized ID Generator Inspired By Twitter Snowflake
### System Diagram
An application calls the ID generator to generate a new ID. For example, a social networking application calls the ID generator to assign a unique ID to each post.
This is how the request will flow:

![image](https://user-images.githubusercontent.com/33947539/150530978-b57d3ff6-eb55-4618-a1fd-a4056a32dbe7.png)

Each new post reaches the load balancer and is directed to an application server. The application server calls the distributed ID generator to assign a unique ID to the new request. The ID generator creates an ID and returns it to the application server.

Next, letâ€™s zoom into the â€œID Generatorâ€ block in the above diagram and understand how it works. Hereâ€™s the system diagram for the ID Generator:

![image](https://user-images.githubusercontent.com/33947539/150531573-e15beb14-0a3e-4f56-b95d-8255eeb81199.png)

When a new request reaches the ID Generator, a vacant id of datatype â€˜longâ€™ is generated. This id has 64 bits that are initially vacant.
Next, the system will determine the time of the request and append this epoch time 22 bits to the left in the id so that thereâ€™s space for appending the Node ID and Counter later on.
Next, the system determines the Node ID (or Machine ID) and fills it into the id, 12 bits to the left, leaving space for the counter.
Finally, the system appends the counter (incrementing with every new request).
The final ID is returned to the application server. The application server will store this id against the request in its database.


### Steps Followed by ID Generator
#### Generating the Epoch Timestamp

>The epoch timestamp is the number of seconds that have elapsed since January 1, 1970, midnight (GMT). However, since our timestamp needs to be of millisecond precision, we will use EpochMilli to find the timestamp in milliseconds.








