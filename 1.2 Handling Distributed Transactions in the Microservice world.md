# Handling Distributed Transactions in the Microservice world

## What is a distributed transaction?
Transactions that span over multiple physical systems or computers over the network, are simply termed Distributed Transactions. In the world of microservices a transaction is now distributed to multiple services that are called in a sequence to complete the entire transaction.

Here is a monolithic e-commerce system using transactions:

![image](https://user-images.githubusercontent.com/33947539/151691034-a0031bba-5736-4d51-8b05-0febb37baea0.png)

In the system above, if a user sends a Checkout request to the platform, the platform will create a local database transaction that works over multiple database tables, to Process the order and Reserve items from the inventory. If any step fails, the transaction can roll back, both the order and items reserved. This is known as ACID (Atomicity, Consistency, Isolation, Durability), which is guaranteed by the database system.

ðŸ‘‰ Here is the e-commerce system decomposed as microservices:

![image](https://user-images.githubusercontent.com/33947539/151691081-5423f61c-1f58-45d6-9110-6c201e1d6f6c.png)

>When we decompose this system, we created the microservices OrderMicroservice and InventoryMicroservice, which have separate databases. When a Checkout request comes from the user, both these microservices will be invoked to apply changes into their own database. Because the transaction is now across multiple databases via multiple systems, it is now considered a distributed transaction.

## Whatâ€™s the problem with distributed transactions in microservices?

With the advent of microservice architecture we are losing the ACID nature of databases. Transactions may now span multiple microservices and therefore databases. The key problems we would face are:

### How do we keep the transaction atomic?
Atomicity means that in a transaction either all steps are completed or no step is completed. In the example above, if the â€˜reserve itemsâ€™ in the InventoryMicroservice method fails, how do we roll back the â€˜process orderâ€™ changes that were applied by the OrderMicroservice?

### How do we handle concurrent requests?
If an object from any one of the microservice is being persisted to the database and at the same time, another request reads the same object. Should the service return the old data or new ? In the example above, once OrderMicroservice is complete and the InventoryMicroservice is now performing its update, should requests for number of orders placed by the customer include the current order?

ðŸ‘† **Possible Solutions**

The above two problems are pretty crucial while designing and building microservice based applications. To address them the following list of approaches have been described:
      1. *Two-Phase Commit*
      2. *Eventual Consistency and Compensation / SAGA*



